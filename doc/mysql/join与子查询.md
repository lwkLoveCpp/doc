### 一、先明确：子查询的两种类型，性能天差地别

首先要区分子查询的类型，这是判断性能的关键：

|子查询类型|定义|性能特点|示例|
|---|---|---|---|
|关联子查询|子查询依赖外部查询的字段（如 `WHERE EXISTS`）|可能被优化为 JOIN，性能较好|`SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.id = t1.id)`|
|非关联子查询|子查询独立于外部查询，仅返回单值 / 列表|易产生临时表、重复执行，性能较差|`SELECT * FROM t1 WHERE version = (SELECT version FROM t2 WHERE id=1)`|

我们常说 “子查询慢”，主要针对 **非关联子查询**；而关联子查询可能被 MySQL 优化器自动转为 JOIN，性能与显式 JOIN 接近。

### 二、核心原因：JOIN 与子查询的执行逻辑差异

#### 1. JOIN 的执行逻辑：高效的 “关联匹配”

JOIN 是将两个表通过「关联条件」（如 `t1.id = t2.id`）直接匹配，MySQL 优化器会选择最优的执行方式：

- **嵌套循环连接（Nested Loop Join）**：小表作为 “驱动表”，大表作为 “被驱动表”，用驱动表的每行数据去匹配被驱动表的索引（类似 “查字典”），无需全表扫描；
- **哈希连接（Hash Join，MySQL 8.0 + 支持）**：对小表构建哈希表，再扫描大表匹配哈希表，适合无索引的大表关联；
- **排序合并连接（Sort Merge Join）**：适合两个表都已排序的场景，合并排序结果即可，避免嵌套循环的多次查找。

#### 关键优势：

- 仅扫描两张表各一次（或驱动表一次、被驱动表通过索引快速查找）；
- 优化器可通过「表大小、索引情况」选择最优驱动表和连接方式，最小化 IO 开销。

#### 示例（JOIN 执行流程）：

```sql
-- t1（小表，100行），t2（大表，10万行），t2.id 有索引
SELECT t1.* FROM t1 JOIN t2 ON t1.id = t2.id;
```

执行流程：

1. 优化器选择 t1 作为驱动表，全扫描 t1（100 行）；
2. 对 t1 的每行数据，用 `t1.id` 去匹配 t2 的索引（t2.id），每次匹配仅需 1 次索引查找（O (logN)）；
3. 总 IO 开销 = 扫描 t1（100 行） + 100 次索引查找（t2），效率极高。

#### 2. 非关联子查询的执行逻辑：低效的 “分离执行”

非关联子查询的执行是「先执行子查询，再执行外部查询」，两者完全分离，优化器无法联动优化：

- 步骤 1：执行子查询，生成临时表（存储结果集，如单值、列表）；
- 步骤 2：将临时表的结果代入外部查询，执行外部查询。

#### 关键问题：

- **临时表开销**：子查询结果若较大，会生成磁盘临时表（而非内存临时表），读写磁盘的 IO 开销远高于内存操作；
- **无索引可用**：临时表默认无索引（除非手动创建），外部查询匹配时可能全表扫描；
- **重复执行**：若子查询在外部查询的 `WHERE` clause 中且外部查询扫描多行，子查询可能被重复执行（如 `SELECT * FROM t1 WHERE t1.id IN (SELECT t2.id FROM t2 WHERE t2.status=1)`，若 t1 有 1000 行，子查询可能执行 1000 次）。

#### 示例（非关联子查询执行流程）：

```sql
-- 非关联子查询：先查 t2，再查 t1
SELECT * FROM t1 WHERE version = (SELECT version FROM t2 WHERE id=1);
```

执行流程：

1. 执行子查询 `SELECT version FROM t2 WHERE id=1`，生成临时表（1 行数据）；
2. 执行外部查询 `SELECT * FROM t1 WHERE version = 临时表的version`，若 t1.version 无索引，全扫描 t1；
3. 若子查询结果是列表（如 `IN` 子查询），且 t1 数据量大，临时表无索引，外部查询会低效匹配。

### 三、MySQL 优化器的 “偏心”：对 JOIN 更友好

MySQL 优化器（Optimizer）的核心目标是「最小化 IO 开销」，而 JOIN 的执行逻辑更易被优化器掌控：

1. **JOIN 支持 “表重排”**：优化器会根据表的大小、索引情况，自动选择最优驱动表（小表驱动大表），减少被驱动表的查找次数；
2. **JOIN 可利用索引下推（ICP）、覆盖索引**：关联条件若命中索引，可直接在存储引擎层过滤数据，减少回表开销；
3. **子查询优化支持有限**：
    - 非关联子查询的临时表无法被优化器关联，只能被动代入；
    - 早期 MySQL 版本（5.6 及以下）对 subquery 的优化较弱，容易生成低效执行计划（如 `NOT IN` 子查询可能导致全表扫描）。

#### 反例：关联子查询可能被优化为 JOIN

并非所有子查询都慢，**关联子查询**（如 `EXISTS` 子查询）可能被 MySQL 优化器自动转为 JOIN，性能与显式 JOIN 接近：

```sql
-- 关联子查询（EXISTS）
SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.id = t1.id);

-- 可能被优化为等价的 JOIN：
SELECT t1.* FROM t1 JOIN t2 ON t1.id = t2.id;
```

此时两者性能差异极小，因为优化器最终生成的执行计划一致。

### 四、哪些场景子查询可能比 JOIN 快？

JOIN 并非万能，以下场景子查询可能更优：

1. **子查询返回单值，且外部查询有索引**：
 ```sql
    -- 子查询返回单值，t1.version 有索引
    SELECT * FROM t1 WHERE version = (SELECT version FROM t2 WHERE id=1);
    ```
    此时子查询仅执行一次（快速获取单值），外部查询通过索引快速匹配，性能与 JOIN 接近；
2. **子查询过滤后结果极小（如 1 行）**：
    
    子查询生成的临时表极小（内存中），外部查询匹配时开销可忽略；
3. **`EXISTS` 子查询（关联子查询）**：
    
    优化器转为 JOIN 后，性能无差异，且 `EXISTS` 语义更清晰（判断 “存在性”）。

### 五、实战建议：如何选择 JOIN 还是子查询？

1. **优先用 JOIN 的场景**：
    - 多表关联查询（如查询用户 + 订单 + 商品信息）；
    - 子查询结果集较大（如返回 1000+ 行）；
    - 非关联子查询（避免临时表开销）；
2. **可用子查询的场景**：
    - 仅需判断 “存在性”（用 `EXISTS`，语义更清晰）；
    - 子查询返回单值（如获取某条数据的最新版本号）；
    - 子查询逻辑简单，且结果集极小；
3. **避坑点**：
    - 避免 `NOT IN` 非关联子查询（易全表扫描，可用 `LEFT JOIN + IS NULL` 替代）；
    - 子查询结果集较大时，手动转为 JOIN 并确保关联字段有索引；
    - 用 `EXPLAIN` 查看执行计划：若子查询出现 `Using temporary`（临时表）、`Using filesort`（文件排序），优先转为 JOIN。