### 一、乐观锁的核心逻辑（思想）

乐观锁假设 “并发冲突概率低”，允许多个事务同时读取数据，仅在**提交更新时**检查数据是否被其他事务修改：

1. 读取数据时，记录数据的 “版本号” 或 “时间戳”；
2. 提交更新时，对比当前数据的版本号与之前记录的版本号；
3. 若版本号一致（无冲突），则更新数据并递增版本号；
4. 若版本号不一致（已被修改），则放弃更新（或重试）。

整个过程**不主动加锁**，仅通过逻辑校验避免冲突，因此称为 “乐观锁”。

### 二、MySQL 中乐观锁的实现方式（实战）

#### 1. 基于版本号（Version）实现（最常用）

#### （1）表结构设计：新增版本号字段

在表中添加 `version` 字段（整数类型，初始值 0），用于记录数据版本：

sql

```sql
CREATE TABLE products (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(50) NOT NULL,
  stock INT NOT NULL COMMENT '库存',
  version INT NOT NULL DEFAULT 0 COMMENT '版本号' -- 乐观锁核心字段
);

-- 插入测试数据
INSERT INTO products (name, stock) VALUES ('iPhone 15', 100);
```

#### （2）乐观锁逻辑：查询 + 更新校验

sql

```sql
-- 步骤1：查询数据，记录版本号（事务A）
SELECT id, stock, version FROM products WHERE id = 1;
-- 结果：id=1, stock=100, version=0

-- 步骤2：提交更新时，对比版本号（仅当版本号一致时更新）
UPDATE products 
SET stock = stock - 1, version = version + 1 -- 更新库存+递增版本号
WHERE id = 1 AND version = 0; -- 关键：条件中携带之前记录的版本号

-- 步骤3：判断更新结果（影响行数=1 表示成功，=0 表示冲突）
SELECT ROW_COUNT(); -- MySQL 函数：返回上一条 SQL 影响的行数
-- 影响行数=1：更新成功（无冲突）
-- 影响行数=0：更新失败（数据已被其他事务修改）
```

#### （3）并发冲突处理示例

- 事务 A 查询到 `version=0`，准备更新；
- 事务 B 同时查询到 `version=0`，并抢先执行 `UPDATE`（`version` 变为 1）；
- 事务 A 执行 `UPDATE` 时，`WHERE version=0` 条件不满足，影响行数 = 0，更新失败；
- 事务 A 可选择重试（重新查询最新版本号再更新）或返回冲突提示。

#### 2. 基于时间戳（Timestamp）实现（类似版本号）

原理与版本号一致，只是用时间戳字段记录数据最后修改时间：

sql

```sql
CREATE TABLE products (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(50) NOT NULL,
  stock INT NOT NULL,
  update_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP -- 自动更新时间戳
);

-- 更新逻辑：对比时间戳
UPDATE products 
SET stock = stock - 1
WHERE id = 1 AND update_time = '2025-12-01 10:00:00'; -- 之前查询到的时间戳

-- 判断影响行数：=1 成功，=0 冲突
```

### 三、乐观锁 vs 悲观锁（行锁 / 表锁）

|对比维度|乐观锁（版本号 / 时间戳）|悲观锁（行锁 / 表锁）|
|---|---|---|
|核心思想|假设无冲突，提交时检查|假设必有冲突，操作前加锁|
|实现方式|业务逻辑（版本号 + UPDATE 条件）|数据库原生锁（FOR UPDATE / 表锁）|
|锁竞争|无锁竞争，性能高|有锁竞争，可能阻塞|
|适用场景|高并发、低冲突（如电商库存、订单）|低并发、高冲突（如金融交易）|
|冲突处理|重试 / 放弃更新|阻塞等待锁释放|

### 四、关键注意事项

1. **仅适用于 “读多写少” 场景**：若冲突频繁（如秒杀场景），乐观锁会因大量重试导致性能下降，此时适合用悲观锁（行锁）；
2. **不能替代悲观锁**：乐观锁仅能避免 “更新冲突”，无法解决 “脏读、不可重复读” 等事务隔离问题，需配合 MySQL 事务隔离级别（如 Repeatable Read）；
3. **版本号字段必须参与更新**：更新时需递增版本号（或更新时间戳），否则无法检测后续冲突；
4. **避免幻读**：乐观锁仅校验单条数据的版本，若涉及批量操作（如批量扣减库存），需结合其他机制（如 `SELECT ... FOR UPDATE` 锁定批量数据）。

### 五、典型应用场景（电商库存扣减）


```sql
-- 事务：扣减库存（乐观锁实现）
BEGIN;
-- 1. 查询商品信息和版本号
SELECT stock, version FROM products WHERE id = 1 FOR UPDATE; -- 此处可加行锁避免幻读，结合乐观锁双重保障
-- 2. 业务逻辑判断（如库存是否充足）
IF stock > 0 THEN
  -- 3. 乐观锁更新
  UPDATE products 
  SET stock = stock - 1, version = version + 1 
  WHERE id = 1 AND version = #{之前查询的version};
  
  -- 4. 检查更新结果
  IF ROW_COUNT() = 1 THEN
    -- 更新成功，继续后续逻辑（如创建订单）
    COMMIT;
  ELSE
    -- 冲突，回滚重试
    ROLLBACK;
    -- 重试逻辑（如循环查询+更新）
  END IF;
ELSE
  -- 库存不足，回滚
  ROLLBACK;
END IF;
```

### 总结

- MySQL 中**没有原生的 “乐观锁” 类型**，乐观锁是通过「版本号 / 时间戳 + 业务逻辑」实现的并发控制思想；
- 核心实现：查询时记录版本号，更新时通过 `WHERE 版本号=xxx` 校验冲突，无冲突则更新并递增版本；
- 优势：无锁竞争、性能高，适合高并发低冲突场景（如库存、订单）；
- 局限：冲突频繁时重试成本高，需配合事务隔离级别或悲观锁解决复杂并发问题。

#### 乐观锁优化
##### 1. 方案一：合并 “读 + 写” 为单 SQL（彻底减少一次读库）

这是最直接的优化 —— 不需要单独查询版本号，而是在 `UPDATE` 语句中**直接通过业务条件关联版本号**，用 `JOIN` 或子查询一次性完成 “读版本 + 写校验”。

 适用场景：知道业务唯一键（如订单号、商品 ID），无需先读取业务数据。
###### 示例（商品库存扣减）：


```sql
-- 优化前：先读（SELECT stock, version FROM products WHERE id=1），再写（UPDATE ... WHERE version=xxx）
-- 优化后：单 SQL 完成“读版本+更新”，无需单独读库
UPDATE products 
SET stock = stock - 1, version = version + 1 
WHERE id = 1 
  AND version = (SELECT version FROM products WHERE id = 1 FOR UPDATE SKIP LOCKED); -- 子查询读版本，避免并发冲突

-- 或用 JOIN 写法（性能更优，避免子查询嵌套）
UPDATE products p
JOIN (SELECT id, version FROM products WHERE id = 1 LIMIT 1) p_old 
  ON p.id = p_old.id AND p.version = p_old.version
SET p.stock = p.stock - 1, p.version = p.version + 1;

-- 判断是否成功：通过 ROW_COUNT() 检查影响行数（1=成功，0=冲突）
SELECT ROW_COUNT();
```

#### 原理：

- 子查询 /`JOIN` 会在 `UPDATE` 执行时原子性读取版本号，避免单独的 `SELECT` 往返；
- 结合 `FOR UPDATE SKIP LOCKED` 可防止高并发下的锁等待（可选，根据隔离级别调整）。

#### 性能提升：

减少 1 次数据库网络往返（通常可降低 30%+ 延迟，网络差时效果更明显）。