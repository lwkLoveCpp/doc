跳表（Skip List）被认为并发性能较高，核心原因在于其**数据结构的局部性修改特性**，使得并发操作时的锁冲突概率更低，且无需像平衡树（如 B + 树、红黑树）那样涉及大范围的节点调整。具体原因如下：

### 一、跳表的修改操作仅涉及局部节点

跳表的插入、删除和更新操作主要影响**相邻的少数节点**，不会像平衡树那样引发连锁性的结构调整：

  

- **插入流程**：通过随机算法确定新节点的层级，只需修改新节点前后相邻节点的指针（最多涉及该节点所有层级对应的前驱和后继节点），不影响其他无关节点。
- **删除流程**：仅需找到待删除节点，修改其前驱节点的指针以跳过该节点，同样只涉及局部节点的指针变更。
- **对比平衡树**：B + 树或红黑树的插入 / 删除可能触发旋转、分裂、合并等操作，这些操作可能涉及多个层级的节点（如父节点、祖父节点甚至整棵树的平衡），导致需要锁定的范围更大。

  

这种局部性修改的特性，使得跳表在并发场景下只需对**少量节点加锁**（甚至可以用无锁 CAS 操作），大大降低了锁冲突的概率。

### 二、细粒度锁的实现更简单

跳表的层级结构允许使用**细粒度锁**（如每个节点独立加锁），而非对整个数据结构加全局锁：

  

- 例如，插入一个节点时，只需锁定该节点在各层级的前驱和后继节点，其他节点的读写操作不受影响。
- 平衡树由于存在父子节点的强依赖关系（如 B + 树的父节点存储子节点的索引），修改一个节点可能需要锁定其所有祖先节点，锁的范围更大，容易引发并发阻塞。

  

细粒度锁的优势在高并发场景下尤为明显：多个线程可以同时操作跳表的不同区域（如不同区间的节点），而不会相互阻塞。

### 三、无锁并发实现的可行性更高

跳表的指针修改操作是**原子性友好**的，适合用无锁编程（如 CAS 指令）实现并发控制：

  

- 跳表的节点指针修改是单一的内存地址更新（如将节点 A 的 next 指针从 B 改为 C），可以通过 CAS（Compare-And-Swap）原子操作完成，无需加锁。
- 平衡树的结构调整往往涉及多个指针的联动修改（如 B + 树分裂时需同时修改父节点的索引和子节点的链接），CAS 操作难以覆盖多步修改，必须依赖锁机制，否则容易出现数据不一致。

  

例如，Redis 的跳表实现中，虽然主要使用单线程模型，但理论上其结构允许通过 CAS 实现无锁并发，而 B + 树的无锁实现则复杂得多（如需要处理节点分裂时的多指针同步）。

### 四、范围查询的并发友好性

跳表的范围查询（如遍历某区间的元素）可以通过**底层链表顺序扫描**实现，过程中无需锁定整个结构：

  

- 遍历开始时只需锁定起始节点，之后随着遍历推进，逐步释放已访问节点的锁并锁定下一个节点，其他线程可以同时修改未被遍历的节点。
- 平衡树的范围查询通常依赖叶子节点的链表，但树结构的修改可能影响叶子节点的链接关系，需要更严格的锁控制（如锁定整个叶子链表）。

### 总结

跳表的并发性能优势源于其**局部修改特性、细粒度锁的易实现性和无锁编程的适配性**。相比平衡树，跳表在并发操作时的锁冲突更少、实现复杂度更低，因此更适合高并发场景（如 Redis 的有序集合、LevelDB 的 MemTable 等）。