```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <chrono>

// 模拟资源
class Resource {
private:
    int id;
public:
    Resource(int id) : id(id) {}
    int getID() const { return id; }
    void use() const {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
};

// 资源池管理类（仅使用mutex和条件变量）
class ResourcePool {
private:
    std::queue<Resource*> resources;
    std::mutex mtx;                   // 仅使用基础mutex
    std::condition_variable cv;       // 条件变量
    int maxResources;
    bool isShutdown;

public:
    ResourcePool(int max) : maxResources(max), isShutdown(false) {
        for (int i = 0; i < maxResources; ++i) {
            resources.push(new Resource(i));
        }
    }

    ~ResourcePool() {
        shutdown();
        while (!resources.empty()) {
            delete resources.front();
            resources.pop();
        }
    }

    // 申请资源（手动控制锁）
    Resource* acquire() {
        mtx.lock();  // 手动获取锁
        
        // 等待资源可用或关闭（循环检查避免虚假唤醒）
        while (!isShutdown && resources.empty()) {
            // 释放锁并等待通知，被唤醒后会重新竞争锁
            cv.wait(mtx);  // 注意：此处传入的是mutex，内部会自动解锁并等待
        }
        
        // 若已关闭，返回空指针
        if (isShutdown) {
            mtx.unlock();  // 手动释放锁
            return nullptr;
        }
        
        // 获取资源
        Resource* res = resources.front();
        resources.pop();
        std::cout << "线程 " << std::this_thread::get_id() 
                  << " 获取资源 " << res->getID() 
                  << "，剩余资源: " << resources.size() << std::endl;
        
        mtx.unlock();  // 手动释放锁
        return res;
    }

    // 释放资源（手动控制锁）
    void release(Resource* res) {
        if (!res) return;
        
        mtx.lock();  // 手动获取锁
        
        if (isShutdown) {
            delete res;
            mtx.unlock();  // 手动释放锁
            return;
        }
        
        resources.push(res);
        std::cout << "线程 " << std::this_thread::get_id() 
                  << " 释放资源 " << res->getID() 
                  << "，剩余资源: " << resources.size() << std::endl;
        
        cv.notify_one();  // 通知等待的线程
        mtx.unlock();     // 手动释放锁
    }

    void shutdown() {
        mtx.lock();
        isShutdown = true;
        cv.notify_all();  // 唤醒所有等待线程
        mtx.unlock();
    }
};

// 工作线程函数
void worker(ResourcePool& pool, int workerId) {
    for (int i = 0; i < 3; ++i) {
        Resource* res = pool.acquire();
        if (!res) {
            std::cout << "工作线程 " << workerId << " 无法获取资源，资源池已关闭" << std::endl;
            return;
        }
        
        std::cout << "工作线程 " << workerId << " 使用资源 " << res->getID() << std::endl;
        res->use();
        
        pool.release(res);
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
    std::cout << "工作线程 " << workerId << " 完成工作" << std::endl;
}

int main() {
    const int MAX_RESOURCES = 3;
    const int NUM_WORKERS = 5;
    
    ResourcePool pool(MAX_RESOURCES);
    std::vector<std::thread> workers;
    
    for (int i = 0; i < NUM_WORKERS; ++i) {
        workers.emplace_back(worker, std::ref(pool), i);
    }
    
    for (auto& t : workers) {
        t.join();
    }
    
    return 0;
}
```


```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// 模拟资源
type Resource struct {
	id int
}

func NewResource(id int) *Resource {
	return &Resource{id: id}
}

func (r *Resource) GetID() int {
	return r.id
}

func (r *Resource) Use() {
	// 模拟资源使用
	time.Sleep(100 * time.Millisecond)
}

// 资源池管理类
type ResourcePool struct {
	resources   []*Resource    // 资源队列
	mu          sync.Mutex     // 互斥锁
	cond        *sync.Cond     // 条件变量
	maxResources int           // 最大资源数量
	isShutdown  bool           // 关闭标志
}

func NewResourcePool(max int) *ResourcePool {
	pool := &ResourcePool{
		maxResources: max,
		isShutdown:   false,
	}
	// 初始化条件变量（绑定互斥锁）
	pool.cond = sync.NewCond(&pool.mu)
	// 预先创建资源
	for i := 0; i < max; i++ {
		pool.resources = append(pool.resources, NewResource(i))
	}
	return pool
}

// 释放资源池所有资源
func (p *ResourcePool) Close() {
	p.mu.Lock()
	defer p.mu.Unlock()
	
	p.isShutdown = true
	p.cond.Broadcast() // 唤醒所有等待的 goroutine
	
	// 释放所有资源
	for _, res := range p.resources {
		res = nil // 让GC回收
	}
	p.resources = nil
}

// 申请资源
func (p *ResourcePool) Acquire() *Resource {
	p.mu.Lock()
	defer func() {
		// 不需要在这里解锁，因为等待时会释放锁，唤醒后需要手动控制
	}()
	
	// 等待资源可用或资源池关闭（循环检查避免虚假唤醒）
	for !p.isShutdown && len(p.resources) == 0 {
		// 释放锁并等待通知，被唤醒后会重新获取锁
		p.cond.Wait()
	}
	
	// 如果资源池已关闭，返回空
	if p.isShutdown {
		p.mu.Unlock()
		return nil
	}
	
	// 获取资源（从切片尾部取，效率更高）
	res := p.resources[len(p.resources)-1]
	p.resources = p.resources[:len(p.resources)-1]
	
	fmt.Printf("goroutine %d 获取资源 %d，剩余资源: %d\n",
		getGoroutineID(), res.GetID(), len(p.resources))
	
	p.mu.Unlock()
	return res
}

// 释放资源
func (p *ResourcePool) Release(res *Resource) {
	if res == nil {
		return
	}
	
	p.mu.Lock()
	defer p.mu.Unlock()
	
	// 如果资源池已关闭，直接丢弃资源
	if p.isShutdown {
		return
	}
	
	// 将资源放回队列
	p.resources = append(p.resources, res)
	fmt.Printf("goroutine %d 释放资源 %d，剩余资源: %d\n",
		getGoroutineID(), res.GetID(), len(p.resources))
	
	// 通知一个等待的 goroutine
	p.cond.Signal()
}

// 工作函数（模拟工作线程）
func worker(pool *ResourcePool, workerId int) {
	for i := 0; i < 3; i++ {
		res := pool.Acquire()
		if res == nil {
			fmt.Printf("工作 goroutine %d 无法获取资源，资源池已关闭\n", workerId)
			return
		}
		
		fmt.Printf("工作 goroutine %d 使用资源 %d\n", workerId, res.GetID())
		res.Use()
		
		pool.Release(res)
		time.Sleep(50 * time.Millisecond)
	}
	fmt.Printf("工作 goroutine %d 完成工作\n", workerId)
}

// 获取当前 goroutine ID（仅用于调试）
func getGoroutineID() uint64 {
	b := make([]byte, 64)
	b = b[:runtime.Stack(b, false)]
	var id uint64
	fmt.Sscanf(string(b), "goroutine %d ", &id)
	return id
}

import "runtime" // 为了获取goroutine ID

func main() {
	const (
		MAX_RESOURCES = 3
		NUM_WORKERS   = 5
	)
	
	pool := NewResourcePool(MAX_RESOURCES)
	defer pool.Close()
	
	var wg sync.WaitGroup
	wg.Add(NUM_WORKERS)
	
	// 启动工作 goroutine
	for i := 0; i < NUM_WORKERS; i++ {
		go func(workerId int) {
			defer wg.Done()
			worker(pool, workerId)
		}(i)
	}
	
	wg.Wait()
}
```
使用条件变量本质上是在防止CPU空转，因为不用条件变量使其进入等待队列，那将不断while循环去判断资源是否满足。